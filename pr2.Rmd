---
title: 'Project 2: Modeling and Evaluation'
author: 'Nam Yoon Kim | GTUsername: nkim84 | GTID: 902948845'
subtitle: "CSE6242 - Data and Visual Analytics - Fall 2017\n\nDue: Friday, April 27, 2018 at 7:59 AM EDT"
output:
  pdf_document: default
  html_notebook: default
---

# Data

We will use the same dataset as Project 1: [`movies_merged`](https://s3.amazonaws.com/content.udacity-data.com/courses/gt-cs6242/project/movies_merged).

# Objective

Your goal in this project is to build a linear regression model that can predict the `Gross` revenue earned by a movie based on other variables. You may use R packages to fit and evaluate a regression model (no need to implement regression yourself). Please stick to linear regression, however.

# Instructions

You should be familiar with using an [RMarkdown](http://rmarkdown.rstudio.com) Notebook by now. Remember that you have to open it in RStudio, and you can run code chunks by pressing *Cmd+Shift+Enter*.

Please complete the tasks below and submit this R Markdown file (as **pr2.Rmd**) containing all completed code chunks and written responses, and a PDF export of it (as **pr2.pdf**) which should include the outputs and plots as well.

_Note that **Setup** and **Data Preprocessing** steps do not carry any points, however, they need to be completed as instructed in order to get meaningful results._

# Setup
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path='Figs/',
                      echo=FALSE, warning=FALSE, message=FALSE)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
require(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=75),tidy=TRUE)
```

Same as Project 1, load the dataset into memory:

```{r}
load('movies_merged')
```

This creates an object of the same name (`movies_merged`). For convenience, you can copy it to `df` and start using it:

```{r}
df = movies_merged
cat("Dataset has", dim(df)[1], "rows and", dim(df)[2], "columns", end="\n", file="")
colnames(df)
```

## Load R packages

Load any R packages that you will need to use. You can come back to this chunk, edit it and re-run to load any additional packages later.

```{r}
library(ggplot2)
library(olsrr)
library(tm)
```

If you are using any non-standard packages (ones that have not been discussed in class or explicitly allowed for this project), please mention them below. Include any special instructions if they cannot be installed using the regular `install.packages('<pkg name>')` command.

**Non-standard packages used**: None

# Data Preprocessing

Before we start building models, we should clean up the dataset and perform any preprocessing steps that may be necessary. Some of these steps can be copied in from your Project 1 solution. It may be helpful to print the dimensions of the resulting dataframe at each step.

## 1. Remove non-movie rows

```{r}
# TODO: Remove all rows from df that do not correspond to movies
df <- df[df$Type == "movie", ]
dim(df)
```

## 2. Drop rows with missing `Gross` value

Since our goal is to model `Gross` revenue against other variables, rows that have missing `Gross` values are not useful to us.

```{r}
# TODO: Remove rows with missing Gross value
df <- subset(df, !is.na(Gross) & Gross != 0)
```

## 3. Exclude movies released prior to 2000

Inflation and other global financial factors may affect the revenue earned by movies during certain periods of time. Taking that into account is out of scope for this project, so let's exclude all movies that were released prior to the year 2000 (you may use `Released`, `Date` or `Year` for this purpose).

```{r}
# TODO: Exclude movies released prior to 2000
df <- df[df$Year >= 2000, ]
```

## 4. Eliminate mismatched rows

_Note: You may compare the `Released` column (string representation of release date) with either `Year` or `Date` (numeric representation of the year) to find mismatches. The goal is to avoid removing more than 10% of the rows._

```{r}
# TODO: Remove mismatched rows
df$Released <- as.numeric(format(df$Released, "%Y"))
df$mismatch <- 0
for(i in seq_along(df$Title)){
  if(is.na(df$Year[i]) & is.na(df$Released[i]) & is.na(df$Date[i]))
    df$mismatch[i] = 0
  else if(is.na(df$Year[i]) & is.na(df$Released[i]))
    df$mismatch[i] = 0
  else if(is.na(df$Year[i]) & is.na(df$Date[i]))
    df$mismatch[i] = 0
  else if(is.na(df$Released[i]) & is.na(df$Date[i]))
    df$mismatch[i] = 0
  else if(is.na(df$Year[i])){
    if(abs(df$Released - df$Date) > 1)
      df$mismatch[i] = 1
    else
      df$mismatch[i] = 0
  }
  else if(is.na(df$Released[i])){
    if(abs(df$Year[i] - df$Date[i]) > 1)
      df$mismatch[i] = 1
    else
      df$mismatch[i] = 0
  }
  else if(is.na(df$Date[i])){
    if(abs(df$Released[i] - df$Year[i]) > 1)
      df$mismatch[i] = 1
    else
      df$mismatch[i] = 0
  }
  else if(!is.na(df$Year[i]) & !is.na(df$Released[i]) & !is.na(df$Date[i])){
    if(abs(df$Released[i] - df$Year[i]) > 1 | abs(df$Released[i] - df$Date[i]) > 1 | abs(df$Year[i] - df$Date[i]) > 1)
      df$mismatch[i] = 1
    else
      df$mismatch[i] = 0
  }
}
mismatch <- sum(df$mismatch) # number of mismatches based on the built criterion is 112
df <- subset(df, mismatch != 1) # removing mismatched rows
percRemovedRows <- (1 - nrow(df)/3062) * 100
cat("Based on my removal logic, the number of rows remain in the resulting dataset is", nrow(df), end="\n", file="")
cat("The number of removed rows is ", mismatch, end="\n", file="")
cat("The percentage of removed rows is", percRemovedRows,"%", end="\n", file="")
```

## 5. Drop `Domestic_Gross` column

`Domestic_Gross` is basically the amount of revenue a movie earned within the US. Understandably, it is very highly correlated with `Gross` and is in fact equal to it for movies that were not released globally. Hence, it should be removed for modeling purposes.

```{r}
# TODO: Exclude the `Domestic_Gross` column
df$Domestic_Gross <- NULL
```

## 6. Process `Runtime` column

```{r}
# TODO: Replace df$Runtime with a numeric column containing the runtime in minutes
runtime <- c() # new empty runtime
for(i in seq_along(df$Runtime)){
  x <- unlist(strsplit(df$Runtime[i], " "))
  if(length(x) == 1){
    runtime <- c(runtime, NA)
  }
  else if(length(x) == 2){
    if(x[2] == "min"){
      runtime <- c(runtime, as.numeric(gsub(",", "", x[1])))
    }
    else if(x[2] == "h"){
      runtime <- c(runtime, 60 * as.numeric(gsub(",", "", x[1])))
    }
  }
  else if(length(x) == 4){
    if(x[2] == "h"){
      runtime <- c(runtime, 60 * as.numeric(gsub(",", "", x[1])) + as.numeric(gsub(",", "", x[3])))
    }
  }
  else{
    runtime <- c(runtime, NA)
  }
}
df$Runtime <- runtime
# replaced string contained "min" i.e. "70 min" to numeric 70
# replaced string contained "min" i.e. "1,618 min" to numeric 1618
# replaced string contained "h" i.e. "1 h" to numeric 60
# replaced string contained "h & min" i.e. "1h 25 min" to numeric 85
```

Perform any additional preprocessing steps that you find necessary, such as dealing with missing values or highly correlated columns (feel free to add more code chunks, markdown blocks and plots here as necessary).

```{r}
# TODO(optional): Additional preprocessing
# Remove variables those are not going to be considered
df$mismatch <- NULL
df$Type <- NULL
df$Response <- NULL
df$imdbID <- NULL
df$tomatoURL <- NULL
df$Poster <- NULL
df$Website <- NULL
```

_**Note**: Do NOT convert categorical variables (like `Genre`) into binary columns yet. You will do that later as part of a model improvement task._

## Final preprocessed dataset

Report the dimensions of the preprocessed dataset you will be using for modeling and evaluation, and print all the final column names. (Again, `Domestic_Gross` should not be in this list!)

```{r}
# TODO: Print the dimensions of the final preprocessed dataset and column names
cat("The dimensions of the preprocessed dataset are", dim(df)[1], "rows and", dim(df)[2], "columns.", end="\n", file="")
cat("All the final column names are:", end="\n", file="")
colnames(df)
```

# Evaluation Strategy

In each of the tasks described in the next section, you will build a regression model. In order to compare their performance, you will compute the training and test Root Mean Squared Error (RMSE) at different training set sizes.

First, randomly sample 10-20% of the preprocessed dataset and keep that aside as the **test set**. Do not use these rows for training! The remainder of the preprocessed dataset is your **training data**.

Now use the following evaluation procedure for each model:

- Choose a suitable sequence of training set sizes, e.g. 10%, 20%, 30%, ..., 100% (10-20 different sizes should suffice). For each size, sample that many inputs from the training data, train your model, and compute the resulting training and test RMSE.
- Repeat your training and evaluation at least 10 times at each training set size, and average the RMSE results for stability.
- Generate a graph of the averaged train and test RMSE values as a function of the train set size (%), with optional error bars.

You can define a helper function that applies this procedure to a given set of features and reuse it.

```{r}
# Define helper functions
# function for Root Mean Squared Error
rmse <- function(error){
  sqrt(mean(error^2))
}

RMSE_calculate <- function(model, test){
  train_error <- summary(model)$residuals
  train_RMSE <- (mean(train_error*train_error))^0.5
  test_predicted <- predict(model, test)
  test_actual <- test$Gross
  test_error <- test_actual - test_predicted
  test_RMSE <- (mean(test_error[!is.na(test_error)]*test_error[!is.na(test_error)]))^0.5
  r_sq <- summary(model)$r.squared
  return(c(train_RMSE,test_RMSE,r_sq))
}


# different sampling size
sampling <- function(train, perc){
  trainRowIndex <- sample(1:nrow(train), floor((perc/100) * nrow(train)))
  sample <- train[trainRowIndex,]
  return(sample)
}

# comma_splitter for names
commasplit_names <- function(x)
unlist(strsplit(as.character(x), ", "))
```

# Tasks

Each of the following tasks is worth 20 points, for a total of 100 points for this project. Remember to build each model as specified, evaluate it using the strategy outlined above, and plot the training and test errors by training set size (%).

## 1. Numeric variables

Use Linear Regression to predict `Gross` based on available _numeric_ variables. You can choose to include all or a subset of them.

```{r}
# TODO: Build & evaluate model 1 (numeric variables only)
# Numeric 
numeric <- sapply(df, function(x) is.numeric(x))
# Subsetting only numeric vairable data frame
numeric <- sapply(df, function(x) is.numeric(x))
df_numeric <- df[, numeric]
# replacing all NAs into its columns' median
df_numeric <- as.data.frame(vapply(df_numeric, function(x) replace(x, is.na(x), median(x, na.rm = TRUE)), FUN.VALUE = numeric(nrow(df_numeric))))
df_numeric$Released <- NULL
df_numeric$Date <- NULL
numeric_variables <- colnames(df_numeric)
# do.call(paste, c(as.list(numeric_variables), sep= ", "))

# Training & Evaluation
set.seed(123)
testIndex <- sample(nrow(df_numeric), as.integer(0.2 * nrow(df_numeric)))
train_set <- df_numeric[-testIndex, ] # training data
test_set <-  df_numeric[testIndex, ]# test data

training_seq <- seq(10,100,10) # sequence of training set sizes
mean_train_RMSE <- c()
mean_test_RMSE <- c()
mean_r_sq <-c()
df_temp <- data.frame(matrix(ncol = 12, nrow = 20))
x_temp <- c("Training Size (%)", "Dataset","Run1", "Run2", "Run3", "Run4", "Run5", "Run6", "Run7", "Run8", "Run9", "Run10")
colnames(df_temp) <- x_temp
df_temp[, 1] <- training_seq
df_temp[1:10, 2] <- c("Train")
df_temp[11:20, 2] <- c("Test")
count <- 1
for(perc in training_seq){
  train_vec <- c()
  test_vec <- c()
  r_vec <- c()
  for(i in 1:10){
    sample_set <- sampling(train_set, perc)
    model <- lm(Gross~Year+Runtime+imdbRating+imdbVotes+tomatoMeter+tomatoRating+tomatoReviews+tomatoFresh+tomatoRotten+tomatoUserMeter+tomatoUserRating+tomatoUserReviews+Budget, data = sample_set)
    # model <- lm(Gross~Year+Runtime+imdbRating+imdbVotes+tomatoMeter+tomatoRating+tomatoUserRating+tomatoUserReviews+Budget, data = sample_set)
    train_vec[i] <- RMSE_calculate(model, test_set)[1]
    test_vec[i] <- RMSE_calculate(model,test_set)[2]
    r_vec[i] <- RMSE_calculate(model,test_set)[3]
  }
  df_temp[count, 3:12] <- train_vec
  df_temp[10 + count, 3:12] <- test_vec
  mean_train_RMSE[count] <- mean(train_vec)
  mean_test_RMSE[count] <- mean(test_vec)
  mean_r_sq[count] <- mean(r_vec)
  
  count = count + 1
}

df_plot_numeric <- data.frame(matrix(ncol = 4, nrow = 10))
colnames(df_plot_numeric) <- c("Training_Size", "train_RMSE", "test_RMSE", "R_squared")
df_plot_numeric[, 1] <- training_seq
df_plot_numeric[, 2] <- mean_train_RMSE
df_plot_numeric[, 3] <- mean_test_RMSE
df_plot_numeric[, 4] <- mean_r_sq

ggplot(df_plot_numeric, aes(x = training_seq)) + 
  geom_point(aes(x = training_seq, y = mean_train_RMSE, color = "train_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_train_RMSE, color = "train_RMSE")) +
  geom_point(aes(x = training_seq, y = mean_test_RMSE, color = "test_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_test_RMSE, color = "test_RMSE"))  + 
  labs(title = "RMSE vs. Training Size for Numeric Variables", x = "Training Size", y = "RMSE")

sort_df_numeric <- aggregate(Training_Size ~ test_RMSE, df_plot_numeric, function(x) min(x))
cat("The best mean test RMSE value is", sort_df_numeric[1, 1], "at", sort_df_numeric[1, 2], "% of the training set size.", end="\n", file="")
summary(model)
```

**Q**: List the numeric variables you used.

**A**: The numeric variables used for Task 1 are "Year, Runtime, imdbRating, imdbVotes, tomatoMeter, tomatoRating, tomatoReviews, tomatoFresh, tomatoRotten, tomatoUserMeter, tomatoUserRating, tomatoUserReviews, Budget". Since variables "Released" & "Date" were redundant because of  "Year" variable thus removed.


**Q**: What is the best mean test RMSE value you observed, and at what training set size?

**A**: The best mean test RMSE value obatained for Task 1 is 93528663 at 100 % of the training set size.


## 2. Feature transformations

Try to improve the prediction quality from **Task 1** as much as possible by adding feature transformations of the numeric variables. Explore both numeric transformations such as power transforms and non-numeric transformations of the numeric variables like binning (e.g. `is_budget_greater_than_3M`).

```{r}
# TODO: Build & evaluate model 2 (transformed numeric variables only)
df_ft_tr <- df_numeric
iqr_data <- df_ft_tr$Gross
Q3 <- quantile(iqr_data, 0.75)
Q1 <- quantile(iqr_data, 0.25)
df_ft_tr$Binning <- 0
for(i in seq_along(df_ft_tr$Gross)){
  if(df_ft_tr$Gross[i] <= Q1)
    df_ft_tr$Binning[i] = "Less than or equal to Q1"
  else if(df_ft_tr$Gross[i] <= Q3)
    df_ft_tr$Binning[i] = "Less than or equal to Q3"
  else
    df_ft_tr$Binning[i] = "Larger than Q3"
}

##########################################################
###### Variable selection method of Package ‘olsrr’ ######
model_initial <- lm(Gross ~ Year + Runtime + imdbRating + imdbVotes + tomatoMeter + tomatoRating + tomatoReviews + tomatoFresh + tomatoRotten + tomatoUserMeter + tomatoUserRating + tomatoUserReviews + Budget, data = df_ft_tr[sample(nrow(df_ft_tr), as.integer(0.2 * nrow(df_ft_tr))), ])
k <- ols_step_all_possible(model_initial)
plot(k)

variable_examined <- c("Year", "Runtime", "imdbRating", "imdbVotes", "tomatoMeter", "tomatoRating", "tomatoFresh", "tomatoRotten", "tomatoUserMeter", "tomatoUserRating", "tomatoUserReviews", "Budget")

model_revised <- lm(Gross ~ Year + Runtime + imdbRating + imdbVotes + tomatoMeter + tomatoRating + tomatoFresh + tomatoRotten + tomatoUserMeter +  tomatoUserRating + tomatoUserReviews + Budget, data = df_ft_tr[sample(nrow(df_ft_tr), as.integer(0.2 * nrow(df_ft_tr))), ])
k1 <- ols_step_best_subset(model_revised)
plot(k1)
##########################################################

# Training & Evaluation
set.seed(123)
testIndex2 <- sample(nrow(df_ft_tr), as.integer(0.2 * nrow(df_ft_tr)))
train_set2 <- df_ft_tr[-testIndex2, ] # training data
test_set2 <-  df_ft_tr[testIndex2, ]# test data

training_seq <- seq(10,100,10) # sequence of training set sizes
mean_train_RMSE2 <- c()
mean_test_RMSE2 <- c()
mean_r_sq2 <-c()
df_temp2 <- data.frame(matrix(ncol = 12, nrow = 20))
x_temp2 <- c("Training Size (%)", "Dataset","Run1", "Run2", "Run3", "Run4", "Run5", "Run6", "Run7", "Run8", "Run9", "Run10")
colnames(df_temp2) <- x_temp2
df_temp2[, 1] <- training_seq
df_temp2[1:10, 2] <- c("Train")
df_temp2[11:20, 2] <- c("Test")
count <- 1
for(perc in training_seq){
  train_vec2 <- c()
  test_vec2 <- c()
  r_vec2 <- c()
  for(i in 1:10){
    sample_set2 <- sampling(train_set2, perc)
    # model2 <- lm(Gross~Year+Runtime+imdbRating+imdbVotes+tomatoMeter+tomatoRating+tomatoFresh+tomatoRotten+tomatoUserMeter+tomatoUserRating+tomatoUserReviews+Budget+I(Budget^2)+I(Budget^3)+I(Budget^4)+I(Runtime^2)+I(Runtime^3)+I(Runtime^4), data = sample_set2)
    model2 <- lm(Gross~Runtime+imdbRating+imdbVotes+tomatoMeter+tomatoRating+tomatoUserRating+tomatoUserReviews+Budget+I(Budget^3)+I(Budget^4)+I(Runtime^2)+I(Runtime^3)+I(Runtime^4), data = sample_set2)
    train_vec2[i] <- RMSE_calculate(model2, test_set2)[1]
    test_vec2[i] <- RMSE_calculate(model2, test_set2)[2]
    r_vec2[i] <- RMSE_calculate(model2, test_set2)[3]
  }
  df_temp2[count, 3:12] <- train_vec2
  df_temp2[10 + count, 3:12] <- test_vec2
  mean_train_RMSE2[count] <- mean(train_vec2)
  mean_test_RMSE2[count] <- mean(test_vec2)
  mean_r_sq2[count] <- mean(r_vec2)
  
  count = count + 1
}

df_plot_ft_tr <- data.frame(matrix(ncol = 4, nrow = 10))
colnames(df_plot_ft_tr) <- c("Training_Size", "train_RMSE", "test_RMSE", "R_squared")
df_plot_ft_tr[, 1] <- training_seq
df_plot_ft_tr[, 2] <- mean_train_RMSE2
df_plot_ft_tr[, 3] <- mean_test_RMSE2
df_plot_ft_tr[, 4] <- mean_r_sq2

ggplot(df_plot_ft_tr, aes(x = training_seq)) + 
  geom_point(aes(x = training_seq, y = mean_train_RMSE2, color = "train_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_train_RMSE2, color = "train_RMSE")) +
  geom_point(aes(x = training_seq, y = mean_test_RMSE2, color = "test_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_test_RMSE2, color = "test_RMSE"))  + 
  labs(title = "RMSE vs. Training Size for Feature Transformations", x = "Training Size", y = "RMSE")

sort_df_ft_tr <- aggregate(Training_Size ~ test_RMSE, df_plot_ft_tr, function(x) min(x))
cat("The best mean test RMSE value is", sort_df_ft_tr[1, 1], "at", sort_df_ft_tr[1, 2], "% of the training set size.", end="\n", file="")
summary(model2)
```

**Q**: Explain which transformations you used and why you chose them.

**A**: First of all, the 1st & 3rd quantile values of Gross column were found. Then, I have divided Gross into 3 binning terms (non-numeric transformations of the numeric variables). 

1) "Less than or equal to Q1"
2) "Less than or equal to Q3"
3) "Larger than Q3"

The same variables used for Task 1 were used to build initial model to improved. Using the variable selection method of Package ‘olsrr’, variables that makes the best subset of the dataset were chosen (which was the dropping of "tomatoRevies" column).

From the Project 1, it was seen that the non-linear relationships between "Gross vs. Budget" & "Gross vs. Runtime", the power transforms were used for these two variables.

**Q**: How did the RMSE change compared to Task 1?

**A**: Comparing to best mean test RMSE value from Task 1 (93528663), the obtained best mean test RMSE value for Task 2 is 93280185 at 90 % of the training size which is observed to be reduced than Task 1. The reduced amount is not significant but there was an improvement in R-squared value as well (from 0.7267 to 0.7529: Task 1 -> Task2).


## 3. Non-numeric variables

Write code that converts genre, actors, directors, and other categorical variables to columns that can be used for regression (e.g. binary columns as you did in Project 1). Also process variables such as awards into more useful columns (again, like you did in Project 1). Now use these converted columns only to build your next model.

```{r}
# TODO: Build & evaluate model 3 (converted non-numeric variables only)
# Replace "Genre, Director, Actors & Country" columns with a collection of binary columns
df_non_numeric <- subset(df, !is.na(Genre) & Genre != "N/A" & !is.na(Director) & Director != "N/A" & !is.na(Actors) & Actors != "N/A" & !is.na(Country) & Country != "N/A" & !is.na(Awards) & Awards != "N/A") # remove all the NAs in chosen non-numeric columns 

##### Genre #####
df_non_numeric$Genre <- gsub(",", "", df_non_numeric$Genre)
genre <- VectorSource(df_non_numeric$Genre)
corp_genre <- Corpus(genre)
dictionary_genre <- DocumentTermMatrix(corp_genre, control = list(tolower = FALSE))
df_dictionary_genre <- data.frame(as.matrix(dictionary_genre))
countGenre <- colSums(as.matrix(dictionary_genre)) # counting all the 1s within the columns of dictionary
sortedCountGenre <- sort(countGenre, decreasing = TRUE) # sorting in descending order
topTenGenre <- sortedCountGenre[1:10] # top 10 genres
# Binding
df_non_numeric <- cbind(df_non_numeric, df_dictionary_genre) # binding df_dictionary along with df_genre
GenreDrop <- c(names(sortedCountGenre[11:length(sortedCountGenre)]))
df_non_numeric <- df_non_numeric[, !(names(df_non_numeric) %in% GenreDrop)]

##### Director #####
director <- VectorSource(df_non_numeric$Director)
director_dict <- as.vector(unlist(strsplit(as.character(df_non_numeric$Director), ", ")))
corp_director <- VCorpus(director)
dictionary_director <- DocumentTermMatrix(corp_director, control = list(tokenize = 
commasplit_names, dictionary = director_dict, tolower = FALSE))
count_director <- colSums(as.matrix(dictionary_director))
sortedCount_director <- sort(count_director, decreasing = TRUE) # sorting in descending order
top10director <- sortedCount_director[1:10] # top 10 directors
df_dictionary_director <- as.data.frame(as.matrix(dictionary_director))
director_names_valid <- names(top10director)
# Binding
df_non_numeric <- cbind(df_non_numeric, df_dictionary_director) # binding df_dictionary along with df_genre
DirectorDrop <- c(names(sortedCount_director[11:length(sortedCount_director)]))
df_non_numeric <- df_non_numeric[, !(names(df_non_numeric) %in% DirectorDrop)]

##### Actors #####
actors <- VectorSource(df_non_numeric$Actors)
actors_dict <- as.vector(unlist(strsplit(as.character(df_non_numeric$Actors), ", ")))
corp_actors <- VCorpus(actors)
dictionary_actors <- DocumentTermMatrix(corp_actors, control = list(tokenize = 
commasplit_names, dictionary = actors_dict, tolower = FALSE))
count_actors <- colSums(as.matrix(dictionary_actors))
sortedCount_actors <- sort(count_actors, decreasing = TRUE) # sorting in descending order
top10actors <- sortedCount_actors[1:10] # top 10 actors
df_dictionary_actors <- as.data.frame(as.matrix(dictionary_actors))
actor_names_valid <- names(top10actors)
# Binding
df_non_numeric <- cbind(df_non_numeric, df_dictionary_actors) # binding df_dictionary along with df_genre
ActorDrop <- c(names(sortedCount_actors[11:length(sortedCount_actors)]))
df_non_numeric <- df_non_numeric[, !(names(df_non_numeric) %in% ActorDrop)]

##### Country #####
# Binary colimns for Country
df_non_numeric$Country <- gsub(" ", "", df_non_numeric$Country)
df_non_numeric$Country <- gsub(",", " ", df_non_numeric$Country)
country <- VectorSource(df_non_numeric$Country)
corp_country <- Corpus(country)
dictionary_country <- DocumentTermMatrix(corp_country, control = list(tolower = FALSE))
count_country <- colSums(as.matrix(dictionary_country))
sortedCount_country <- sort(count_country, decreasing = TRUE) # sorting in descending order
top10country <- sortedCount_country[1:10] # top 10 countries
df_dictionary_country <- as.data.frame(as.matrix(dictionary_country))
country_names_valid <- names(top10country)
# Binding
df_non_numeric <- cbind(df_non_numeric, df_dictionary_country) # binding df_dictionary along with df_genre
CountryDrop <- c(names(sortedCount_country[11:length(sortedCount_country)]))
df_non_numeric <- df_non_numeric[, !(names(df_non_numeric) %in% CountryDrop)]

##### Awards #####
df_awards <- df_non_numeric
df_awards$award <- 0
df_awards$nomination <- 0
# df_awards_valid <- subset(df_awards, Awards != "N/A" & !is.na(Awards)) # remove all the NAs in Awards column
df_awards_valid <- df_awards
df_awards_valid <- df_awards_valid[, c("Title", "Gross", "Awards", "award", "nomination")]
award_split <- (strsplit(df_awards_valid$Awards, "(\\s+)|(?=[[:punct:]])", perl = TRUE)) # list of strsplitted Award columns
df_award_split <- data.frame(matrix(award_split))
df_award_split$won <- 0
df_award_split$win <- 0
df_award_split$wins <- 0
df_award_split$total_wins <- 0
df_award_split$nominated <- 0
df_award_split$nomination <- 0
df_award_split$nominations <- 0
df_award_split$total_nominations <- 0

for(i in seq_along(df_award_split$matrix.award_split.)){
  if('Won' %in% unlist(df_award_split$matrix.award_split.[i]) == TRUE){
    ind <- match('Won', unlist(df_award_split$matrix.award_split.[i]))
    df_award_split$won[i] <- as.numeric(unlist(df_award_split$matrix.award_split.[i])[ind + 1])
  }
  if('win' %in% unlist(df_award_split$matrix.award_split.[i]) == TRUE){
    ind <- match('win', unlist(df_award_split$matrix.award_split.[i]))
    df_award_split$win[i] <- as.numeric(unlist(df_award_split$matrix.award_split.[i])[ind - 1])
  }
  if('wins' %in% unlist(df_award_split$matrix.award_split.[i]) == TRUE){
    ind <- match('wins', unlist(df_award_split$matrix.award_split.[i]))
    df_award_split$wins[i] <-as.numeric(unlist(df_award_split$matrix.award_split.[i])[ind - 1])
  }
  if('Nominated' %in% unlist(df_award_split$matrix.award_split.[i]) == TRUE){
    ind <- match('Nominated', unlist(df_award_split$matrix.award_split.[i]))
    df_award_split$nominated[i] <-as.numeric(unlist(df_award_split$matrix.award_split.[i])[ind + 2])
  }
  if('nomination' %in% unlist(df_award_split$matrix.award_split.[i]) == TRUE){
    ind <- match('nomination', unlist(df_award_split$matrix.award_split.[i]))
    df_award_split$nomination[i] <-as.numeric(unlist(df_award_split$matrix.award_split.[i])[ind - 1])
  }
  if('nominations' %in% unlist(df_award_split$matrix.award_split.[i]) == TRUE){
    ind <- match('nominations', unlist(df_award_split$matrix.award_split.[i]))
    df_award_split$nominations[i] <-as.numeric(unlist(df_award_split$matrix.award_split.[i])[ind - 1])
  }
}
df_award_split$total_wins <- df_award_split$won + df_award_split$win + df_award_split$wins
df_award_split$total_nominations <- df_award_split$nominated + df_award_split$nomination + df_award_split$nominations
df_awards_valid$award <- df_award_split$total_wins
df_awards_valid$nomination <- df_award_split$total_nominations
# Binding
df_non_numeric$Award <- df_awards_valid$award
df_non_numeric$Nomination<- df_awards_valid$nomination

# do.call(paste, c(as.list(colnames(df_non_numeric)), sep = "`+`"))

# Training & Evaluation
set.seed(123)
testIndex3 <- sample(nrow(df_non_numeric), as.integer(0.2 * nrow(df_non_numeric)))
train_set3 <- df_non_numeric[-testIndex3, ] # training data
test_set3 <-  df_non_numeric[testIndex3, ]# test data

training_seq <- seq(10,100,10) # sequence of training set sizes
mean_train_RMSE3 <- c()
mean_test_RMSE3 <- c()
mean_r_sq3 <-c()
df_temp3 <- data.frame(matrix(ncol = 12, nrow = 20))
x_temp3 <- c("Training Size (%)", "Dataset","Run1", "Run2", "Run3", "Run4", "Run5", "Run6", "Run7", "Run8", "Run9", "Run10")
colnames(df_temp3) <- x_temp3
df_temp3[, 1] <- training_seq
df_temp3[1:10, 2] <- c("Train")
df_temp3[11:20, 2] <- c("Test")
count <- 1
for(perc in training_seq){
  train_vec3 <- c()
  test_vec3 <- c()
  r_vec3 <- c()
  for(i in 1:10){
    sample_set3 <- sampling(train_set3, perc)
    model3 <- lm(Gross~`Horror`+`Adventure`+`Comedy`+`Crime`+`Drama`+`Thriller`+`Romance`+`Fantasy`+`Action`+`Mystery`+`Ethan Coen`+`Joel Coen`+`Ridley Scott`+`Robert Rodriguez`+`Ron Howard`+`Shawn Levy`+`Steven Soderbergh`+`Steven Spielberg`+`Adam Sandler`+`Ben Stiller`+`Bruce Willis`+`Cameron Diaz`+`Christian Bale`+`Johnny Depp`+`Mark Wahlberg`+`Matt Damon`+`Robert De Niro`+`Samuel L. Jackson`+`Canada`+`Germany`+`USA`+`India`+`France`+`Italy`+`Spain`+`Australia`+`Ireland`+`Japan`+`Award`+`Nomination`, data = sample_set3)
    # model3 <- lm(Gross~`Adventure`+`Crime`+`Drama`+`Fantasy`+`Action`+`Ridley Scott`+`Robert Rodriguez`+`Steven Spielberg`+`Adam Sandler`+`Ben Stiller`+`Cameron Diaz`+`Johnny Depp`+`Canada`+`USA`+`Award`+`Nomination`, data = sample_set3)
    train_vec3[i] <- RMSE_calculate(model3, test_set3)[1]
    test_vec3[i] <- RMSE_calculate(model3, test_set3)[2]
    r_vec3[i] <- RMSE_calculate(model3, test_set3)[3]
  }
  df_temp3[count, 3:12] <- train_vec3
  df_temp3[10 + count, 3:12] <- test_vec3
  mean_train_RMSE3[count] <- mean(train_vec3)
  mean_test_RMSE3[count] <- mean(test_vec3)
  mean_r_sq3[count] <- mean(r_vec3)
  
  count = count + 1
}

df_plot_non_numeric <- data.frame(matrix(ncol = 4, nrow = 10))
colnames(df_plot_non_numeric) <- c("Training_Size", "train_RMSE", "test_RMSE", "R_Squared")
df_plot_non_numeric[, 1] <- training_seq
df_plot_non_numeric[, 2] <- mean_train_RMSE3
df_plot_non_numeric[, 3] <- mean_test_RMSE3
df_plot_non_numeric[, 4] <- mean_r_sq3

ggplot(df_plot_non_numeric, aes(x = training_seq)) + 
  geom_point(aes(x = training_seq, y = mean_train_RMSE3, color = "train_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_train_RMSE3, color = "train_RMSE")) +
  geom_point(aes(x = training_seq, y = mean_test_RMSE3, color = "test_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_test_RMSE3, color = "test_RMSE"))  + 
  labs(title = "RMSE vs. Training Size for Non-numric Variables", x = "Training Size", y = "RMSE")

sort_df_non_numeric <- aggregate(Training_Size ~ test_RMSE, df_plot_non_numeric, function(x) min(x))
cat("The best mean test RMSE value is", sort_df_non_numeric[1, 1], "at", sort_df_non_numeric[1, 2], "% of the training set size.", end="\n", file="")
summary(model3)
```

**Q**: Explain which categorical variables you used, and how you encoded them into features.

**A**: The variables which were used to replace into collections of binary columns are: "Genre, Director, Actors & Country". First of all, all the NAs were removed from the dataset. Then, using the 'tm' packages, all the possible names were collected as dictionary and based on its content of each row, they were converted into 1 and 0s. Using cbind, all the binary columns for each names of "Genre, Director, Actors & Country" were binded with the non-numeric data frame (df_non_numeric). Even though only top 10 most counted names were used, there were more than 5000 columns after binding all the binary columns so the unncessary columns (which were not chosen) were dropped and the model was built based on the top 10 names of the "Genre, Director, Actors & Country" columns. Some modifications were made with getting rid of some variables with p-values higher than 0.05, but did worse in returning RMSE values thus the initially builted model was chosen.

There were way too many variables exist for the selection method of Package ‘olsrr’, thus the model summaries were used for Task 3 - 5. 

**Q**: What is the best mean test RMSE value you observed, and at what training set size? How does this compare with Task 2?

**A**: The best mean test RMSE value obtained for this non-numerical variables is 152255093 at 100 % of the training size. Comparing to the best mean test RMSE value for Task 2 (93280185), the RMSE value for Task 3 is significanlty higher. Even the R-squared value was very low comparing to other models (0.3925).

## 4. Numeric and categorical variables

Try to improve the prediction quality as much as possible by using both numeric and non-numeric variables from **Tasks 2 & 3**.

```{r}
# TODO: Build & evaluate model 4 (numeric & converted non-numeric variables)
df_combined <- df_non_numeric
iqr_data2 <- df_combined$Gross
Q3_2 <- quantile(iqr_data2, 0.75)
Q1_2 <- quantile(iqr_data2, 0.25)
df_ft_tr$Binning <- 0
for(i in seq_along(df_combined$Gross)){
  if(df_combined$Gross[i] <= Q1_2)
    df_combined$Binning[i] = "Less than or equal to Q1"
  else if(df_combined$Gross[i] <= Q3_2)
    df_combined$Binning[i] = "Less than or equal to Q3"
  else
    df_combined$Binning[i] = "Larger than Q3"
}

# Training & Evaluation
set.seed(123)
testIndex4 <- sample(nrow(df_combined), as.integer(0.2 * nrow(df_combined)))
train_set4 <- df_combined[-testIndex4, ] # training data
test_set4 <-  df_combined[testIndex4, ]# test data

training_seq <- seq(10,100,10) # sequence of training set sizes
mean_train_RMSE4 <- c()
mean_test_RMSE4 <- c()
mean_r_sq4 <- c()
df_temp4 <- data.frame(matrix(ncol = 12, nrow = 20))
x_temp4 <- c("Training Size (%)", "Dataset","Run1", "Run2", "Run3", "Run4", "Run5", "Run6", "Run7", "Run8", "Run9", "Run10")
colnames(df_temp3) <- x_temp4
df_temp4[, 1] <- training_seq
df_temp4[1:10, 2] <- c("Train")
df_temp4[11:20, 2] <- c("Test")
count <- 1
for(perc in training_seq){
  train_vec4 <- c()
  test_vec4 <- c()
  r_vec4 <- c()
  for(i in 1:10){
    sample_set4 <- sampling(train_set4, perc)
    # model4 <- lm(Gross~+`Year`+`Runtime`+`imdbRating`+`imdbVotes`+`tomatoMeter`+`tomatoRating`+`tomatoReviews`+`tomatoFresh`+`tomatoRotten`+`tomatoUserMeter`+`tomatoUserRating`+`tomatoUserReviews`+`Budget`+I(`Budget`^2)+I(`Budget`^3)+`Binning`+`Horror`+`Adventure`+`Comedy`+`Crime`+`Drama`+`Thriller`+`Romance`+`Fantasy`+`Action`+`Mystery`+`Ethan Coen`+`Joel Coen`+`Ridley Scott`+`Robert Rodriguez`+`Ron Howard`+`Shawn Levy`+`Steven Soderbergh`+`Steven Spielberg`+`Adam Sandler`+`Ben Stiller`+`Bruce Willis`+`Cameron Diaz`+`Christian Bale`+`Johnny Depp`+`Mark Wahlberg`+`Matt Damon`+`Robert De Niro`+`Samuel L. Jackson`+`Canada`+`Germany`+`USA`+`India`+`France`+`Italy`+`Spain`+`Australia`+`Ireland`+`Japan`+`Award`+`Nomination`, data = sample_set4)
    model4 <- lm(Gross~+`imdbRating`+`imdbVotes`+`tomatoFresh`+`tomatoRotten`+`tomatoUserMeter`+`tomatoUserRating`+`tomatoUserReviews`+`Budget`+I(`Budget`^3)+`Binning`+`Adventure`+`Action`+`Ridley Scott`+`Ben Stiller`+`Cameron Diaz`+`Christian Bale`+`Johnny Depp`+`Australia`+`Nomination`, data = sample_set4)
    train_vec4[i] <- RMSE_calculate(model4, test_set4)[1]
    test_vec4[i] <- RMSE_calculate(model4, test_set4)[2]
    r_vec4[i] <- RMSE_calculate(model4, test_set4)[3]
  }
  df_temp4[count, 3:12] <- train_vec4
  df_temp4[10 + count, 3:12] <- test_vec4
  mean_train_RMSE4[count] <- mean(train_vec4)
  mean_test_RMSE4[count] <- mean(test_vec4)
  
  count = count + 1
}

df_plot_combined <- data.frame(matrix(ncol = 4, nrow = 10))
colnames(df_plot_combined) <- c("Training_Size", "train_RMSE", "test_RMSE", "R_Squared")
df_plot_combined[, 1] <- training_seq
df_plot_combined[, 2] <- mean_train_RMSE4
df_plot_combined[, 3] <- mean_test_RMSE4
df_plot_combined[, 4] <- mean_r_sq4

ggplot(df_plot_combined, aes(x = training_seq)) + 
  geom_point(aes(x = training_seq, y = mean_train_RMSE4, color = "train_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_train_RMSE4, color = "train_RMSE")) +
  geom_point(aes(x = training_seq, y = mean_test_RMSE4, color = "test_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_test_RMSE4, color = "test_RMSE"))  + 
  labs(title = "RMSE vs. Training Size for Numeric and Non-numeric combied", x = "Training Size", y = "RMSE")

sort_df_combined <- aggregate(Training_Size ~ test_RMSE, df_plot_combined, function(x) min(x))
cat("The best mean test RMSE value is", sort_df_combined[1, 1], "at", sort_df_combined[1, 2], "% of the training set size.", end="\n", file="")
summary(model4)
```

**Q**: Compare the observed RMSE with Tasks 2 & 3.

**A**: The best mean test RMSE value for this Task (Task 4) is 99042867 at 100 % of the training set size. Comparing to the observed best mean test RMSE values for Tasks 2 & 3 (93280185 & 152255093). The feature transformations & non-numerical combined model did improve than the Task 3 which was the non-numerical model, but did not achieve better improvement than Task 2. The RMSE value for Task 4 ranged in between Tasks 2 & 3.


## 5. Additional features

Now try creating additional features such as interactions (e.g. `is_genre_comedy` x `is_budget_greater_than_3M`) or deeper analysis of complex variables (e.g. text analysis of full-text columns like `Plot`).

```{r}
# TODO: Build & evaluate model 5 (numeric, non-numeric and additional features)
# # remove all the columns which hava less than 0.5 correlation value to Gross for numeric variable data 
# cor <- cor(df_numeric, df_numeric$Gross) # correlation values of other variables to Gross
# to.remove <- as.vector(colnames(df_numeric)[which(cor[,ncol(cor)] < 0.5)]) # names of numeric columns to be removed which has less than 0.5 correlation value to Gross column
# `%ni%` <- Negate(`%in%`)
# df_numeric_improved <- subset(df_numeric, select = names(df_numeric) %ni% to.remove)
# improved_numeric_var <- c(colnames(df_numeric_improved[,1:3])) # improved numric variables to be used

# Work with high correlation valued numeric variables & variables from Task 4
df_final <- df_combined

##### Rated #####
# Clean out "NOT RATED" & UNRATED
df_final$Rated <- gsub("NOT RATED", "NA", df_final$Rated)
df_final$Rated <- gsub("UNRATED", "NA", df_final$Rated)
df_final <- subset(df_final, !is.na(Rated) & Rated != "N/A" & Rated != "NA")
# binary columns for most common Rated variables "PG", "PG-13", "R"
for(i in seq_along(df_final$Rated)){
  if(df_final$Rated[i] == "R"){
      df_final$R[i] = 1
      df_final$PG[i] = 0
      df_final$`PG-13`[i] = 0
  }
  else if(df_final$Rated[i] == "PG"){
      df_final$R[i] = 0
      df_final$PG[i] = 1
      df_final$`PG-13`[i] = 0
  }
  else if(df_final$Rated[i] == "PG-13"){
      df_final$R[i] = 0
      df_final$PG[i] = 0
      df_final$`PG-13`[i] = 1
  }
}

##### tomatoImage #####
df_final <- subset(df_final, !is.na(tomatoImage) & tomatoImage != "N/A" & Rated != "NA")
for(i in seq_along(df_final$tomatoImage)){
  if(df_final$tomatoImage[i] == "rotten"){
      df_final$Rotten[i] = 1
      df_final$Fresh[i] = 0
      df_final$Certified[i] = 0
  }
  else if(df_final$tomatoImage[i] == "fresh"){
      df_final$Rotten[i] = 0
      df_final$Fresh[i] = 1
      df_final$Certified[i] = 0
  }
  else if(df_final$tomatoImage[i] == "certified"){
      df_final$Rotten[i] = 0
      df_final$Fresh[i] = 0
      df_final$Certified[i] = 1
  }
}

##### Binning Binary #####
for(i in seq_along(df_final$Binning)){
  if(df_final$Binning[i] == "Less than or equal to Q1"){
      df_final$Q1[i] = 1
      df_final$Q2[i] = 0
      df_final$Q3[i] = 0
  }
  else if(df_final$Binning[i] == "Less than or equal to Q3"){
      df_final$Q1[i] = 0
      df_final$Q2[i] = 1
      df_final$Q3[i] = 0
  }
  else if(df_final$Binning[i] == "Larger than Q3"){
      df_final$Q1[i] = 0
      df_final$Q2[i] = 0
      df_final$Q3[i] = 1
  }
}


# Training & Evaluation
set.seed(123)
testIndex5 <- sample(nrow(df_final), as.integer(0.2 * nrow(df_final)))
train_set5 <- df_final[-testIndex5, ] # training data
test_set5 <-  df_final[testIndex5, ]# test data

training_seq <- seq(10,100,10) # sequence of training set sizes
mean_train_RMSE5 <- c()
mean_test_RMSE5 <- c()
mean_r_sq5 <- c()
df_temp5 <- data.frame(matrix(ncol = 12, nrow = 20))
x_temp5 <- c("Training Size (%)", "Dataset","Run1", "Run2", "Run3", "Run4", "Run5", "Run6", "Run7", "Run8", "Run9", "Run10")
colnames(df_temp3) <- x_temp5
df_temp5[, 1] <- training_seq
df_temp5[1:10, 2] <- c("Train")
df_temp5[11:20, 2] <- c("Test")
count <- 1
for(perc in training_seq){
  train_vec5 <- c()
  test_vec5 <- c()
  r_vec5 <- c()
  for(i in 1:10){
    sample_set5 <- sampling(train_set5, perc)
    # model5 <- lm(Gross~+`Year`+`Runtime`+`imdbRating`+`imdbVotes`+`tomatoMeter`+`tomatoRating`+`tomatoReviews`+`tomatoFresh`+`tomatoRotten`+`tomatoUserMeter`+`tomatoUserRating`+`tomatoUserReviews`+`Budget`+I(`Budget`^2)+I(`Budget`^3)+I(`Budget`^4)+`Binning`+`Horror`+`Adventure`+`Comedy`+`Crime`+`Drama`+`Thriller`+`Romance`+`Fantasy`+`Action`+`Mystery`+`Ethan Coen`+`Joel Coen`+`Ridley Scott`+`Robert Rodriguez`+`Ron Howard`+`Shawn Levy`+`Steven Soderbergh`+`Steven Spielberg`+`Adam Sandler`+`Ben Stiller`+`Bruce Willis`+`Cameron Diaz`+`Christian Bale`+`Johnny Depp`+`Mark Wahlberg`+`Matt Damon`+`Robert De Niro`+`Samuel L. Jackson`+`Canada`+`Germany`+`USA`+`India`+`France`+`Italy`+`Spain`+`Australia`+`Ireland`+`Japan`+`Award`+`Nomination`+`Rotten`+`Fresh`+`Certified`+`R`+`PG-13`+`PG`+`Drama`*`Q3`+`Comedy`*`Q3`+`Action`*`Q3`+`Q1`+`Q2`+`Q3`, data = sample_set5)
    model5 <- lm(Gross~`imdbRating`+`imdbVotes`+`tomatoRating`+`tomatoFresh`+`tomatoRotten`+`tomatoUserMeter`+`tomatoUserRating`+`tomatoUserReviews`+`Budget`+I(`Budget`^3)+`Binning`+`Adventure`+`Action`+`Adam Sandler`+`Cameron Diaz`+`Christian Bale`+`Johnny Depp`+`Mark Wahlberg`+`Germany`+`Award`+`Nomination`+`Certified`+`R`+`PG-13`+`PG`+`Drama`*`Q3`+`Q1`+`Q2`+`Q3`, data = sample_set5)
    train_vec5[i] <- RMSE_calculate(model5, test_set5)[1]
    test_vec5[i] <- RMSE_calculate(model5, test_set5)[2]
    r_vec5[i] <- RMSE_calculate(model5, test_set5)[3]
  }
  df_temp5[count, 3:12] <- train_vec5
  df_temp5[10 + count, 3:12] <- test_vec5
  mean_train_RMSE5[count] <- mean(train_vec5)
  mean_test_RMSE5[count] <- mean(test_vec5)
  mean_r_sq5[count] <- mean(r_vec5)
  
  count = count + 1
}

df_plot_final <- data.frame(matrix(ncol = 4, nrow = 10))
colnames(df_plot_final) <- c("Training_Size", "train_RMSE", "test_RMSE", "R_Squared")
df_plot_final[, 1] <- training_seq
df_plot_final[, 2] <- mean_train_RMSE5
df_plot_final[, 3] <- mean_test_RMSE5
df_plot_final[, 4] <- mean_r_sq5

ggplot(df_plot_final, aes(x = training_seq)) + 
  geom_point(aes(x = training_seq, y = mean_train_RMSE5, color = "train_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_train_RMSE5, color = "train_RMSE")) +
  geom_point(aes(x = training_seq, y = mean_test_RMSE5, color = "test_RMSE")) + 
  geom_line(aes(x = training_seq, y = mean_test_RMSE5, color = "test_RMSE"))  + 
  labs(title = "RMSE vs. Training Size for Numeric and Non-numeric combied", x = "Training Size", y = "RMSE")

sort_df_final <- aggregate(Training_Size ~ test_RMSE, df_plot_final, function(x) min(x))
cat("The best mean test RMSE value is", sort_df_final[1, 1], "at", sort_df_final[1, 2], "% of the training set size.", end="\n", file="")
summary(model5)
```

**Q**: Explain what new features you designed and why you chose them.

**A**: Started with the dataset from Task 4 (whihc was the feature transformation & non-numeric combined), in order to improve the model, variables "Rated" & "tomatoImage" were used to converted into binary columns. The reason behind choosing the tomatoImage column is that unlike the other ratings, tomatoImage is the rating system which does not use the numeric values but using three categories of rotten, fresh and certified and I thought of using this would be interesting. Also, the previously used non-numeric transformations of the numeric variables (binnings) were converted into binary columns as well since they had very low p-values in previous models.

`After the model was built for all the Tasks (Task 1- 5), based on the model summary, some variables were droppred in order to produce better results.`

**Q**: Comment on the final RMSE values you obtained, and what you learned through the course of this project.

**A**: The final best mean test RMSE value is 92417552 at 100 % of the training set size. Comparing to the previous Tasks, the model used for this Task came out with the best RMSE value.

Through this project, there are few things that I have learned:

1) how to use the lm() to predict linear model fits.
2) numerical only model would perform better than categorical only model.
3) combining categorical & numeric would perform better than categorical only model.
4) as most plots show: the validation set (test set) starts with high error, on contrast, the training set starts with low error.
5) the test and train sets show convergence as the sample size increases.
6) higher R-squared values imply improvement, however, if R-squared values are too high, it may imply overfitting.
